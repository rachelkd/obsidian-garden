---
{"dg-publish":true,"dg-path":"academia/CSC110/01 Course Notes/10 Abstraction, Classes, Software Design/10.2 Defining Our Own Data Types, Part 3.md","permalink":"/academia/csc-110/01-course-notes/10-abstraction-classes-software-design/10-2-defining-our-own-data-types-part-3/","created":"2023-11-18T22:09:07.469-05:00","updated":"2023-11-20T19:47:57.507-05:00"}
---

#CSC110

**Covered in:**
- [[100 ğŸ“’ Academia/CSC110/02 Lectures/Lecture 26 OOP, Abstract Data Types, and Stacks\|Lecture 26 OOP, Abstract Data Types, and Stacks]]
---
```table-of-contents
```
---
# Removing `@dataclass` header

```python
# @dataclass (We've commented out this line)
class Person:
    """A custom data type that represents data for a person."""
    given_name: str
    family_name: str
    age: int
    address: str


>>> david = Person('David', 'Liu', 100, '40 St. George Street')
TypeError: Person() takes no arguments
```

Creating an instance of the `Person` class with no arguments to fix error:
```python
>>> david = Person()
>>> type(david)
<class 'Person'>
```
<div class="caption" style="color: grey"><i>Successfully created an instance of theÂ Person class</i></div>

What happens when we try to access the instance attributes?
```python
>>> david.given_name
AttributeError: 'Person' object has no attribute 'given_name'
```

# Defining an initializer

`david = Person()`
![init_david_1.png|500](/img/user/Files/init_david_1.png)

- initializer method of a class
	- called when an instance of a class is created
	- purpose is to initialize all of the instance attributes for the new object
	- PythonÂ **always uses the nameÂ `__init__`Â for the initializer method of a class**.

```python
class Person:
    """A custom data type that represents data for a person."""
    given_name: str
    family_name: str
    age: int
    address: str

    def __init__(self, given_name: str, family_name: str, age: int, address: str) -> None:
        """Initialize a new Person object."""
        self.given_name = given_name
        self.family_name = family_name
        self.age = age
        self.address = address
```

- Method functions vs. top-level functions:
	- method definition isÂ _indented_Â so that it is inside the body of theÂ `class Person`Â definition
	- presence of the parameterÂ `self`
		- Every initializer has a first parameter that refers to the instance that has just been created and is to be initialized.
		- type ofÂ `self`Â shouldÂ _always_Â be the class that the initializer belongs to
- `__init__` is called automatically
	- never have to pass a value for `self`

## Visualizing object initialization

State of memory when the `Person.__init__` method is first called:
![person_init.png|500](/img/user/Files/person_init.png)

- `given_name`Â is aÂ _parameter_Â of the initializer, whileÂ `self.given_name`Â is anÂ _instance attribute_

![person_init_2.png|500](/img/user/Files/person_init_2.png)

# What really happens when we create a new object

`__init__` has return type of `None`, but the call to create a new object returns a value.

To evaluate this call, the Python interpreter actually does three things:

1. Create a newÂ `Person`Â object behind the scenes.
2. CallÂ `Person.__init__`Â with the newÂ `Person`Â object passed as the parameterÂ `self`, along with the other arguments.
3. Return the new object. This step is where theÂ `Person`Â object is returned, not directly from the call toÂ `__init__`Â in Step 2.

`__init__` is a helper function in the object creation process.

# Type conversion, revisited

> [!note] 
> Every data type has an initializer.

When we callÂ `int('5')`, becauseÂ `int`Â is a data type, the Python interpreter does three things:

1. Create a newÂ `int`Â object behind the scenes.
2. CallÂ `int.__init__`Â with the new object passed as the parameterÂ `self`, along with the other argumentÂ `'5'`.
3. Return the newÂ `int`Â object.

- Initializer forÂ `int`Â does something different than storingÂ `5`Â in an instance attribute